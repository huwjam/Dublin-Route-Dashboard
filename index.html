<!DOCTYPE html>
<html>
<head>
    <title>Dublin Route Traffic Map</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
        }
        #map {
            height: 70vh;
            width: 100%;
        }
        #directions-panel {
            padding: 20px;
            background: #f9f9f9;
            border-top: 1px solid #ccc;
            max-height: 30vh;
            overflow: auto;
        }
        #summary {
            padding: 10px;
            background: #e0f7fa;
            border-bottom: 1px solid #ccc;
        }
        #alternatives {
            padding: 10px;
            background: #fff3e0;
            border-top: 1px solid #ccc;
        }
        .legend {
            position: absolute;
            right: 12px;
            top: 12px;
            background: rgba(255,255,255,0.95);
            padding: 8px;
            font-size: 13px;
            border-radius: 4px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            cursor: move;
            user-select: none;
            touch-action: none;
            z-index: 1000;
        }
        .legend .item {
            display:flex;
            align-items:center;
            margin: 2px 0;
        }
        .legend .swatch {
            width: 18px;
            height: 8px;
            margin-right: 8px;
            border-radius: 2px;
            display:inline-block;
        }
        .status-hint {
            font-size: 12px;
            color: #555;
            margin-top: 6px;
        }
    </style>
</head>
<body>
    <h2 style="text-align:center;">Traffic Map: Amgen (Dún Laoghaire) → Schoolhouse Hotel (D4)</h2>
    <div id="summary">Loading best route...</div>
    <div id="map"></div>
    <div id="alternatives"></div>
    <div id="directions-panel"></div>

    <div class="legend" id="legend">
        <div><strong>Route delay legend</strong></div>
        <div class="item"><span class="swatch" style="background:green"></span> Minimal delay</div>
        <div class="item"><span class="swatch" style="background:orange"></span> Moderate delay</div>
        <div class="item"><span class="swatch" style="background:red"></span> Severe delay</div>
        <div class="status-hint">
            Note: the Traffic layer (map) shows live congestion. Route delay is computed from duration vs duration_in_traffic.
        </div>
    </div>

    <script>
        function initMap() {
            const map = new google.maps.Map(document.getElementById("map"), {
                zoom: 12,
                center: { lat: 53.319, lng: -6.218 },
            });

            // show the visual traffic overlay
            const trafficLayer = new google.maps.TrafficLayer();
            trafficLayer.setMap(map);

            const directionsService = new google.maps.DirectionsService();
            // We'll suppress the default polyline drawing so we can draw a colored polyline based on delay
            const directionsRenderer = new google.maps.DirectionsRenderer({
                panel: document.getElementById("directions-panel"),
                suppressPolylines: true,
                draggable: false
            });
            directionsRenderer.setMap(map);

            const origin = "Amgen, Dún Laoghaire, Dublin";
            const destination = "Schoolhouse Hotel, Dublin 4, Dublin";

            // request directions
            directionsService.route(
                {
                    origin,
                    destination,
                    travelMode: google.maps.TravelMode.DRIVING,
                    drivingOptions: {
                        departureTime: new Date(),
                        trafficModel: 'best_guess'
                    },
                    provideRouteAlternatives: true
                },
                (response, status) => {
                    // default: assume nothing available
                    const summaryEl = document.getElementById('summary');
                    const altContainer = document.getElementById('alternatives');
                    const dirPanel = document.getElementById('directions-panel');

                    if (status !== 'OK' || !response || !response.routes || response.routes.length === 0) {
                        const msg = status === 'OK' ? 'No routes returned by Directions API.' : ('Directions request failed: ' + status);
                        console.warn(msg, response);
                        summaryEl.innerHTML = `<strong>No route displayed</strong> — ${msg} <div class="status-hint">Check the console for details and verify your API key / billing / permissions.</div>`;
                        altContainer.innerHTML = '';
                        dirPanel.innerHTML = '';
                        return;
                    }

                    // We have routes
                    let bestIndex = 0;
                    let bestDurationTraffic = Number.POSITIVE_INFINITY;
                    const routesInfo = response.routes.map((route, idx) => {
                        const leg = route.legs && route.legs[0];
                        const dur = (leg && leg.duration && leg.duration.value) || Infinity;
                        const durTraffic = (leg && leg.duration_in_traffic && leg.duration_in_traffic.value) || dur;
                        const delaySeconds = durTraffic - dur;
                        if (durTraffic < bestDurationTraffic) {
                            bestDurationTraffic = durTraffic;
                            bestIndex = idx;
                        }
                        return {
                            index: idx,
                            summary: route.summary || `Route ${idx+1}`,
                            durationText: leg && leg.duration ? leg.duration.text : "N/A",
                            durationValue: dur,
                            durationInTrafficText: (leg && leg.duration_in_traffic && leg.duration_in_traffic.text) || null,
                            durationInTrafficValue: durTraffic,
                            delaySeconds
                        };
                    });

                    // render directions and set to best
                    directionsRenderer.setDirections(response);
                    directionsRenderer.setRouteIndex(bestIndex);

                    // draw our polyline for the best route if possible
                    const bestRoute = response.routes[bestIndex];
                    if (bestRoute) {
                        drawColoredRoute(bestRoute, map, routesInfo[bestIndex]);
                    } else {
                        summaryEl.innerHTML = `<strong>No route drawable</strong> — route data missing.`;
                        return;
                    }

                    // Update summary
                    const best = routesInfo[bestIndex];
                    const delayMins = Math.round(best.delaySeconds / 60);
                    const delayPercent = best.durationValue > 0 ? Math.round((best.delaySeconds / best.durationValue) * 100) : 0;
                    const delayMessage = best.delaySeconds > 0
                        ? ` (approx. ${delayMins} min delay — ${delayPercent}% slower than free-flow)`
                        : ` (no significant delay detected)`;

                    summaryEl.innerHTML = `<strong>Best route:</strong> ${response.routes[bestIndex].summary || 'Suggested route'} — Estimated travel time: <strong>${best.durationInTrafficText || best.durationText}</strong>${delayMessage}`;

                    // Show alternatives summary
                    altContainer.innerHTML = "<strong>Route alternatives</strong>";
                    const list = document.createElement('ul');
                    list.style.margin = '6px 0 0 18px';
                    routesInfo.forEach(r => {
                        const li = document.createElement('li');
                        const dm = r.delaySeconds > 0 ? `+${Math.round(r.delaySeconds/60)} min delay` : 'no significant delay';
                        const trafficText = r.durationInTrafficText ? ` — ${r.durationInTrafficText}` : ''; 
                        li.innerHTML = `${r.summary} : ${r.durationText}${trafficText} (${dm})`;
                        if (r.index === bestIndex) {
                            li.style.fontWeight = '700';
                            li.style.marginBottom = '6px';
                        }
                        list.appendChild(li);
                    });
                    altContainer.appendChild(list);
                }
            );

            let customPolyline = null;
            function drawColoredRoute(route, mapInstance, routeInfo) {
                if (!route || !routeInfo) return;

                if (customPolyline) {
                    customPolyline.setMap(null);
                    customPolyline = null;
                }

                const delaySeconds = routeInfo.delaySeconds || 0;
                const delayMinutes = delaySeconds / 60;
                const delayPercent = routeInfo.durationValue > 0 ? (delaySeconds / routeInfo.durationValue) * 100 : 0;
                let color = 'green';
                if (delayMinutes >= 10 || delayPercent > 20) color = 'red';
                else if (delayMinutes >= 5 || delayPercent > 10) color = 'orange';

                const rawPath = route.overview_path || decodeOverviewPolyline(route.overview_polyline && route.overview_polyline.points) || [];
                if (!rawPath || rawPath.length === 0) {
                    console.warn('No overview_path available to draw.');
                    document.getElementById('summary').innerHTML += '<div class="status-hint">Note: route geometry unavailable to draw on the map.</div>';
                    return;
                }

                const path = rawPath.map(p => {
                    if (typeof p.lat === 'function' && typeof p.lng === 'function') return { lat: p.lat(), lng: p.lng() };
                    return p;
                });

                customPolyline = new google.maps.Polyline({
                    path,
                    strokeColor: color,
                    strokeOpacity: 0.95,
                    strokeWeight: 6,
                    zIndex: 5,
                    map: mapInstance
                });

                const bounds = new google.maps.LatLngBounds();
                path.forEach(p => bounds.extend(p));
                mapInstance.fitBounds(bounds);

                customPolyline.addListener('click', () => {
                    const percentText = routeInfo.durationValue > 0 ? `${Math.round((routeInfo.delaySeconds / routeInfo.durationValue) * 100)}%` : '0%';
                    const infowindow = new google.maps.InfoWindow({
                        content: `<div style="font-size:13px"><strong>Selected route</strong><br/>Estimated: ${routeInfo.durationInTrafficText || routeInfo.durationText}<br/>Delay: ${Math.round(routeInfo.delaySeconds/60)} min (${percentText})</div>`,
                        position: path[Math.floor(path.length/2)]
                    });
                    infowindow.open(mapInstance);
                    setTimeout(() => infowindow.close(), 6000);
                });
            }

            function decodeOverviewPolyline(encoded) {
                if (!encoded) return [];
                const points = [];
                let index = 0, lat = 0, lng = 0;
                while (index < encoded.length) {
                    let b, shift = 0, result = 0;
                    do {
                        b = encoded.charCodeAt(index++) - 63;
                        result |= (b & 0x1f) << shift;
                        shift += 5;
                    } while (b >= 0x20);
                    const dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
                    lat += dlat;
                    shift = 0;
                    result = 0;
                    do {
                        b = encoded.charCodeAt(index++) - 63;
                        result |= (b & 0x1f) << shift;
                        shift += 5;
                    } while (b >= 0x20);
                    const dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
                    lng += dlng;
                    points.push({lat: lat / 1e5, lng: lng / 1e5});
                }
                return points;
            }

            // Make the legend draggable (mouse + touch)
            (function makeLegendDraggable() {
                const legend = document.getElementById('legend');
                let isDragging = false;
                let startX = 0, startY = 0, origX = 0, origY = 0;

                legend.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = legend.getBoundingClientRect();
                    origX = rect.left;
                    origY = rect.top;
                    document.body.style.userSelect = 'none';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    legend.style.left = (origX + dx) + 'px';
                    legend.style.top = (origY + dy) + 'px';
                    legend.style.right = 'auto';
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        document.body.style.userSelect = '';
                    }
                });

                // Touch support
                legend.addEventListener('touchstart', (e) => {
                    const t = e.touches[0];
                    isDragging = true;
                    startX = t.clientX;
                    startY = t.clientY;
                    const rect = legend.getBoundingClientRect();
                    origX = rect.left;
                    origY = rect.top;
                }, { passive: true });

                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const t = e.touches[0];
                    const dx = t.clientX - startX;
                    const dy = t.clientY - startY;
                    legend.style.left = (origX + dx) + 'px';
                    legend.style.top = (origY + dy) + 'px';
                    legend.style.right = 'auto';
                }, { passive: true });

                document.addEventListener('touchend', () => {
                    isDragging = false;
                });

            })();
        }
    </script>

    <!-- Replace the API key below with your own key if needed -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDiGpn-bIo5_fBy9geLz4QdEP_r1ORtWs8&callback=initMap"></script>
</body>
</html>
